Triâ€‘Machine Story Universe Generator (Expanded)
A distributed system where each machine simulates a different dimension of a fictional universe, and together they create a persistent, everâ€‘growing story world.
This isnâ€™t a game.
Itâ€™s not a simple generator.
Itâ€™s a living narrative ecosystem.

ğŸŸ© 1. Raspberry Pi 5 â†’ The Chronicle Keeper (Canon + Time + History)
The Pi is the memory of the universe.
Responsibilities
- Stores the canonical timeline
- Tracks characters, factions, locations
- Maintains continuity rules
- Runs the â€œworld clockâ€
- Logs every event generated by the other machines
- Ensures no contradictions (e.g., a character canâ€™t be in two places at once)
- Provides a simple API for querying the universe state
Why the Pi is perfect
Itâ€™s always on, low power, and ideal for:
- maintaining a persistent SQLite/DuckDB database
- running a lightweight FastAPI service
- acting as the authoritative source of truth
Example data stored:
- Characters (traits, arcs, relationships)
- Locations (maps, descriptions, history)
- Events (timestamped, linked to characters/places)
- Factions (alliances, conflicts, goals)
- World rules (magic systems, physics, lore constraints)
The Pi is the librarian of your universe.

ğŸŸ¥ 2. Evoâ€‘X2 Max+ â†’ The Narrative Engine (AI + Simulation + Creativity)
This is the brain of the universe.
Responsibilities
- Generates new events
- Expands lore
- Creates characters, factions, conflicts
- Simulates political, economic, magical, or cosmic systems
- Ensures logical consistency with the Piâ€™s canon
- Runs heavy AI models for:
- dialogue
- plot arcs
- worldbuilding
- character psychology
- procedural cultures
- mythologies
Why Evoâ€‘X2 is perfect
Your workstationâ€™s massive VRAM and compute power let you run:
- large LLMs
- embedding models
- narrative planning algorithms
- simulation engines
This node is the creative force of the world.

ğŸŸ¦ 3. Alienware 18 (UYScuti) â†’ The World Browser (Visualization + Interaction)
This machine is the window into the universe.
Responsibilities
- Renders maps, timelines, character webs
- Displays the evolving story world
- Lets you explore:
- regions
- factions
- histories
- relationships
- event chains
- Provides tools to:
- edit canon
- add constraints
- influence the world
- create â€œwhatâ€‘ifâ€ scenarios
Why Alienware is perfect
Itâ€™s powerful, has great GPU capability, and is ideal for:
- interactive UIs
- 2D/3D visualization
- dashboards
- map rendering
- timeline browsers
This node is the explorer and editor of the world.

ğŸ”„ How the Three Machines Work Together
1. Pi sends a â€œtickâ€ event
Example:
â€œYear 142, Day 12 â€” Winter â€” 3:00 PMâ€
2. Evoâ€‘X2 receives the tick
It decides:
- what events should happen
- which characters act
- what conflicts escalate
- what discoveries occur
- what political shifts happen
It generates structured events like:
- â€œA rebellion begins in the Eastern Provinceâ€
- â€œTwo characters meet and form an allianceâ€
- â€œA magical anomaly appears near the capitalâ€
3. Pi validates and logs the events
- checks for contradictions
- updates the timeline
- updates character runtime state (stored in `character_state`)
- updates global runtime values (stored in `system_state`, e.g., `time`)
4. Alienware pulls updates and visualizes them
- updates the map
- updates the timeline
- updates character relationship graphs
- shows new story arcs
- displays summaries

ğŸ§  What the Universe Becomes Over Time
After days or weeks of running, youâ€™ll have:
- a full timeline spanning centuries
- dozens or hundreds of characters
- evolving political systems
- wars, alliances, betrayals
- religions, myths, technologies
- maps that change over time
- genealogies
- cultural evolution
- magical or scientific discoveries
- emergent story arcs
It becomes a procedural universe bible.

ğŸ› ï¸ Core Technologies (Pythonâ€‘friendly)
Pi (Chronicle Keeper)
- FastAPI
- SQLite or DuckDB
- Pydantic models

Note: The repository layout was flattened on 2026-01-13. See [docs/REPO_LAYOUT_CHANGE.md](docs/REPO_LAYOUT_CHANGE.md).
- ZeroMQ or MQTT
Evoâ€‘X2 (Narrative Engine)
- PyTorch / ONNX Runtime
- Narrative planning algorithms
- Embedding models
- Custom simulation logic
- ZeroMQ or gRPC
Alienware (World Browser)
- PySide6 / Qt
- Electron + Python backend
- Godot (Python bindings)
- Plotly Dash
- NetworkX for relationship graphs

ğŸš€ First Milestone Prototype
A minimal version you can build in a weekend:
Pi:
- stores characters + events
- exposes /add_event and /get_world_state
Evoâ€‘X2:
- generates 1 event per tick
- sends it to Pi
Alienware:
- displays a scrolling list of events
- shows a simple map with character positions
Once that works, you expand outward.

ğŸ¯ Next Step Options
I can now generate:
- a full architecture diagram
- the event protocol
- the database schema
- the Python skeleton for all three nodes
- the world model (magic system, politics, geography)
- the simulation logic for the narrative engine
- the UI layout for the world browser
